目的 : 避免程序出现OOM  OOM == out of memory，加快运行速度

避免出现内存泄露(通常都是全局成员变量持有对象引用所导致的)。

没错，每个程序都会有可使用的内存上限，这被称为堆大小（Heap Size）。 不同的手机，堆大小也不尽相同

垃圾回收
    GC全称是Garbage Collection

在java中，是通过new关键字来为对象分配内存的，而内存的释放是由垃圾收集器（GC）来回收的


个人的感悟总结:
    每个手机，会给他的应用程序分配堆大小(Heap Size),不同的手机，堆大小不同，当应用程序使用的内存大于Heap Size时就会OOM
为了避免OOM，我们有很多可行化的建议:
    一.节制的使用Service
        1.当任务执行完毕，要STOP service,不要让其空跑
        2.为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行
        结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。(有时间需要研究研究IntentService)。
        3.让Service一直在后台运行，这是极其糟糕的做法。
    二.界面不可见时，释放内存(这个比较复杂，暂时没有用到过，难以理解，遇到了参考下面的博客)
    三.当内存紧张时，释放内存(同上)
    四.避免在bitmap上浪费内存，这点很重要，目前项目采用的是ImageLoader开源项目，对bitmap有过优化处理(总之bitmap非常耗内存，需要注意).
    五.使用优化过的数据集合，这个用到的可能性还是比较大的，SparseArray是android里为HashMap<Integer,Object>这样的HashMap而专门写的类,目的是提高效率，其核心是折半查找函数（binarySearch）。(博客:http://liuzhichao.com/p/832.html)

    六.知晓内存的开支情况
    我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：

        使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。
        任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。
        任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。
        在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。

    关于内存的分析，需要借助工具，目前我只看了理论，并没有实践，主要是需要eclipse和其对应的插件，博客中有描述，就此带过.

参考文献：

    Android最佳性能实践(一)——合理管理内存：http://blog.csdn.net/guolin_blog/article/details/42238627

    Android最佳性能实践(二)——分析内存的使用情况 ：http://blog.csdn.net/guolin_blog/article/details/42238633


关于虚拟机内存中堆内存和栈内存的区别和联系
    联系，都是内存的构成部分

    区别：
        1.栈用来存储局部变量(简单数据类型)和方法调用,而堆内存用来存储Java中的对象,无论是成员变量，局部变量(复杂数据类型)，还是类变量，它们指向的对象都存储在堆内存中。
        2.栈内存为线程独享,栈可以理解成线程的私有内存，堆内存为线程共享,堆内存可以被当前进程的所有线程访问.
        3.异常错误，堆内存不足，报OOM错误，栈内存不足报StackOverFlowException
        4.栈内存远远小于堆内存

Java内存分配和回收的机制的概括就是：
        分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。
        年轻代（Young Generation）：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的），这个GC机制被称为Minor GC或叫Young GC
        年老代（Old Generation）：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　
        永久代(方法区)，暂时不做GC考虑。

